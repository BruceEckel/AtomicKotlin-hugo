<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Atomic Kotlin: Operator_Overloading</title>
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="atomickotlin-html.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
  <a href="https://atomickotlin.github.io/">
    <img src="Banner.png" alt="Atomic Kotlin" class="banner-image">
  </a>
</header>
<h1 id="operator-overloading">Operator Overloading</h1>
<blockquote>
<p><strong>This Atom is Under Construction</strong></p>
</blockquote>
<blockquote>
<p>In the context of computer programming, <em>overloading</em> means “adding an extra meaning to something that already exists.”</p>
</blockquote>
<p><em>Operator overloading</em> allows you to take an operator like <code>+</code> and give it meaning for your new type, or an extra meaning for an existing type.</p>
<p>Operator overloading has a tumultuous past. It was popularized in C++, but because C++ had no garbage collection, writing overloaded operators was difficult. As a result, the early Java designers deemed operator overloading “bad” and didn’t allow it in Java, even though Java’s garbage collection would have made it relatively easy. The simplicity of operator overloading when supported by garbage-collection was demonstrated in the Python language, which constrained you to a limited (familiar) set of operators (as did C++). Scala then experimented with allowing you to invent your own operators, causing some programmers to abuse this feature and create truly incomprehensible code. Kotlin learned from all these languages, and has simplified the process of operator overloading but restricts your choices to a reasonable and familiar set of operators. In addition, the rules of operator precedence cannot be changed.</p>
<p><strong>End of sample. See <a href="https://atomickotlin.github.io/">AtomicKotlin.com</a> for full early-access book.</strong></p>
</body>
</html>
