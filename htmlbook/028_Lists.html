<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Atomic Kotlin: Lists</title>
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="atomickotlin-html.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
  <a href="http://AtomicKotlin.com/">
    <img src="Banner.png" alt="Atomic Kotlin" class="banner-image">
  </a>
</header>
<h1 id="lists">Lists</h1>
<blockquote>
<p>A <code>List</code> is a <em>container</em>—something that holds other objects.</p>
</blockquote>
<p>Containers are also called <em>collections</em>. <code>List</code>s are part of the standard Kotlin package so they’re available without any imports. In the following example, we create a <code>List</code> populated with <code>Int</code>s by calling the function <code>listOf()</code> with initialization values:</p>
<div class="sourceCode" id="cb1"><code class="sourceCode kotlin"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="co">// Lists/Lists.kt</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">import</span> <span class="im">atomictest.eq</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="kw">fun</span> <span class="fu">main</span>(<span class="va">args</span>: <span class="dt">Array</span>&lt;<span class="va">String</span>&gt;) {</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">  <span class="co">// Lists hold other objects:</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">  <span class="kw">val</span> <span class="va">ints</span> = listOf(<span class="dv">99</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">11</span>, <span class="dv">13</span>)</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  ints eq <span class="st">&quot;[99, 3, 5, 7, 11, 13]&quot;</span>      <span class="co">// [1]</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">  <span class="co">// Select each element in the List:</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">  <span class="kw">var</span> <span class="va">result</span> = <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">  <span class="cf">for</span> (i <span class="kw">in</span> ints)                      <span class="co">// [2]</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12">    result += <span class="st">&quot;$i &quot;</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13">  result eq <span class="st">&quot;99 3 5 7 11 13 &quot;</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14"></a>
<a class="sourceLine" id="cb1-15" data-line-number="15">  <span class="co">// &quot;[]&quot; is &quot;Indexing&quot;:</span></a>
<a class="sourceLine" id="cb1-16" data-line-number="16">  ints[<span class="dv">4</span>] eq <span class="dv">11</span>                        <span class="co">// [3]</span></a>
<a class="sourceLine" id="cb1-17" data-line-number="17">}</a></code></div>
<ul>
<li><p><strong>[1]</strong> Displaying a <code>List</code> uses square brackets in the output.</p></li>
<li><p><strong>[2]</strong> <code>for</code> loops work well with <code>List</code>s: <code>for(i in ints)</code> means <code>i</code> gets each value in <code>ints</code>. You don’t even declare <code>val i</code> or give its type; Kotlin knows from the context that <code>i</code> is a <code>for</code> loop identifier, and takes care of it for you.</p></li>
<li><p><strong>[3]</strong> Square brackets are used to <em>index</em> into the <code>List</code>. A <code>List</code> keeps its elements in initialization order, and you select them individually by number. Like most programming languages, Kotlin starts indexing at element zero, which in this case produces the value <code>99</code>. Thus, the index of <code>4</code> produces a value of <code>11</code>.</p></li>
</ul>
<p>Forgetting that indexing starts at zero is responsible for the so-called <em>off-by-one</em> error. If you try to use an index beyond the last element in the <code>List</code>, Kotlin will throw an exception to inform you that something has gone wrong. The exception will display an error message telling you it’s an <code>IndexOutOfBoundsException</code> so you can figure out what the problem is:</p>
<div class="sourceCode" id="cb2"><code class="sourceCode kotlin"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co">// Lists/OutOfBounds.kt</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="kw">import</span> <span class="im">atomictest.*</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="kw">fun</span> <span class="fu">main</span>(<span class="va">args</span>: <span class="dt">Array</span>&lt;<span class="va">String</span>&gt;) {</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">  <span class="kw">val</span> <span class="va">ints</span> = listOf(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  capture {</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">    ints[<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">  } eq <span class="st">&quot;ArrayIndexOutOfBoundsException: 3&quot;</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">}</a></code></div>
<p>In a language like Kotlin we often don’t select elements one at a time, but instead <em>iterate</em> through a whole container using <code>in</code>—an approach that eliminates off-by-one errors.</p>
<p><code>List</code> can hold all different types. Here, we create a <code>List</code> of <code>Double</code>s and a <code>List</code> of <code>String</code>s:</p>
<div class="sourceCode" id="cb3"><code class="sourceCode kotlin"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="co">// Lists/ListUsefulFunction.kt</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="kw">import</span> <span class="im">atomictest.eq</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="kw">fun</span> <span class="fu">main</span>(<span class="va">args</span>: <span class="dt">Array</span>&lt;<span class="va">String</span>&gt;) {</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">  <span class="kw">val</span> <span class="va">doubles</span> =</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    listOf(<span class="fl">1.1</span>, <span class="fl">2.2</span>, <span class="fl">3.3</span>, <span class="fl">4.4</span>)</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">  doubles.min() eq <span class="fl">1.1</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8">  doubles.max() eq <span class="fl">4.4</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9"></a>
<a class="sourceLine" id="cb3-10" data-line-number="10">  <span class="kw">val</span> <span class="va">strings</span> = listOf(<span class="st">&quot;Twas&quot;</span>, <span class="st">&quot;Brillig&quot;</span>,</a>
<a class="sourceLine" id="cb3-11" data-line-number="11">    <span class="st">&quot;And&quot;</span>, <span class="st">&quot;Slithy&quot;</span>, <span class="st">&quot;Toves&quot;</span>)</a>
<a class="sourceLine" id="cb3-12" data-line-number="12">  strings eq listOf(<span class="st">&quot;Twas&quot;</span>, <span class="st">&quot;Brillig&quot;</span>,</a>
<a class="sourceLine" id="cb3-13" data-line-number="13">    <span class="st">&quot;And&quot;</span>, <span class="st">&quot;Slithy&quot;</span>, <span class="st">&quot;Toves&quot;</span>)</a>
<a class="sourceLine" id="cb3-14" data-line-number="14">  strings.sorted() eq listOf(<span class="st">&quot;And&quot;</span>,</a>
<a class="sourceLine" id="cb3-15" data-line-number="15">    <span class="st">&quot;Brillig&quot;</span>, <span class="st">&quot;Slithy&quot;</span>, <span class="st">&quot;Toves&quot;</span>, <span class="st">&quot;Twas&quot;</span>)</a>
<a class="sourceLine" id="cb3-16" data-line-number="16">  strings.reversed() eq listOf(<span class="st">&quot;Toves&quot;</span>,</a>
<a class="sourceLine" id="cb3-17" data-line-number="17">    <span class="st">&quot;Slithy&quot;</span>, <span class="st">&quot;And&quot;</span>, <span class="st">&quot;Brillig&quot;</span>, <span class="st">&quot;Twas&quot;</span>)</a>
<a class="sourceLine" id="cb3-18" data-line-number="18">  strings.first() eq <span class="st">&quot;Twas&quot;</span></a>
<a class="sourceLine" id="cb3-19" data-line-number="19">  strings.takeLast(<span class="dv">2</span>) eq</a>
<a class="sourceLine" id="cb3-20" data-line-number="20">    listOf(<span class="st">&quot;Slithy&quot;</span>, <span class="st">&quot;Toves&quot;</span>)</a>
<a class="sourceLine" id="cb3-21" data-line-number="21">}</a></code></div>
<p>This shows some of <code>List</code>’s operations. Note the name “sorted” instead of “sort.” When you call <code>sorted()</code> it <em>produces</em> a new <code>List</code> containing the same elements as the old, in sorted order—but it leaves the original <code>List</code> alone. Calling it “sort” implies that the original <code>List</code> is changed directly (a.k.a. <em>sorted in place</em>). Throughout Kotlin, you see this tendency of “leaving the original object alone and producing a new object.” <code>reversed()</code> produces a new <code>List</code> as well, ordered end to beginning.</p>
<h2 id="parameterized-types">Parameterized Types</h2>
<p>We consider it a good idea to let Kotlin infer types whenever possible. It tends to make the code cleaner and easier to read. Sometimes, however, Kotlin can’t figure out what type to use (if so, it complains) and we must help. In other cases, you have some reason that you want to be explicit about the type, for readability’s sake. For example, here’s how we explicitly tell Kotlin the type contained in a <code>List</code>:</p>
<div class="sourceCode" id="cb4"><code class="sourceCode kotlin"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="co">// Lists/ParameterizedTypes.kt</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="kw">import</span> <span class="im">atomictest.eq</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="kw">fun</span> <span class="fu">main</span>(<span class="va">args</span>: <span class="dt">Array</span>&lt;<span class="va">String</span>&gt;) {</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">  <span class="co">// Type is inferred:</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">  <span class="kw">val</span> <span class="va">numbers</span> = listOf(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">  <span class="kw">val</span> <span class="va">strings</span> =</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">    listOf(<span class="st">&quot;one&quot;</span>, <span class="st">&quot;two&quot;</span>, <span class="st">&quot;three&quot;</span>)</a>
<a class="sourceLine" id="cb4-9" data-line-number="9">  <span class="co">// Exactly the same, but explicitly typed:</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">  <span class="kw">val</span> <span class="va">numbers2</span>: List&lt;<span class="kw">Int</span>&gt; = listOf(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb4-11" data-line-number="11">  <span class="kw">val</span> <span class="va">strings2</span>: List&lt;<span class="kw">String</span>&gt; =</a>
<a class="sourceLine" id="cb4-12" data-line-number="12">    listOf(<span class="st">&quot;one&quot;</span>, <span class="st">&quot;two&quot;</span>, <span class="st">&quot;three&quot;</span>)</a>
<a class="sourceLine" id="cb4-13" data-line-number="13">  numbers eq numbers2</a>
<a class="sourceLine" id="cb4-14" data-line-number="14">  strings eq strings2</a>
<a class="sourceLine" id="cb4-15" data-line-number="15">}</a></code></div>
<p>The initialization values tell the Kotlin compiler that <code>numbers</code> contains a <code>List</code> of <code>Int</code>s, while <code>strings</code> contains a <code>List</code> of <code>String</code>s, so it infers those types.</p>
<p><code>numbers2</code> and <code>strings2</code> are explicitly-typed versions of <code>numbers</code> and <code>strings</code>. On the left sides we add colons and the type declarations <code>List&lt;Int&gt;</code> and <code>List&lt;String&gt;</code>. The angle brackets are new here; they denote a <em>type parameter</em>, allowing us to say, “the container holds objects of the type ‘parameter’.” You typically pronounce <code>List&lt;Int&gt;</code> as “list of <code>Int</code>.”</p>
<p>Type parameters are useful for elements other than containers, but you often see them with container-like objects. In this book we normally use <code>List</code> as a basic container.</p>
<p>Return values can also have type parameters:</p>
<div class="sourceCode" id="cb5"><code class="sourceCode kotlin"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co">// Lists/ParameterizedReturn.kt</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="kw">import</span> <span class="im">atomictest.eq</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="co">// Return type is inferred:</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="kw">fun</span> <span class="fu">inferred</span>(<span class="va">c1</span>: <span class="dt">Char</span>, <span class="va">c2</span>: <span class="dt">Char</span>) =</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">  listOf(c1, c2)</a>
<a class="sourceLine" id="cb5-7" data-line-number="7"></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"><span class="co">// Explicit return type:</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9"><span class="kw">fun</span> <span class="fu">explicit</span>(<span class="va">c1</span>: <span class="dt">Char</span>, <span class="va">c2</span>: <span class="dt">Char</span>): <span class="dt">List</span>&lt;<span class="dt">Char</span>&gt; =</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">  listOf(c1, c2)</a>
<a class="sourceLine" id="cb5-11" data-line-number="11"></a>
<a class="sourceLine" id="cb5-12" data-line-number="12"><span class="kw">fun</span> <span class="fu">main</span>(<span class="va">args</span>: <span class="dt">Array</span>&lt;<span class="va">String</span>&gt;) {</a>
<a class="sourceLine" id="cb5-13" data-line-number="13">  inferred(<span class="ch">&#39;a&#39;</span>, <span class="ch">&#39;b&#39;</span>) eq <span class="st">&quot;[a, b]&quot;</span></a>
<a class="sourceLine" id="cb5-14" data-line-number="14">  explicit(<span class="ch">&#39;y&#39;</span>, <span class="ch">&#39;z&#39;</span>) eq <span class="st">&quot;[y, z]&quot;</span></a>
<a class="sourceLine" id="cb5-15" data-line-number="15">}</a></code></div>
<p>Kotlin infers the return type for <code>inferred()</code>. The definition of <code>explicit()</code> specifies the function return type. You can’t just say it returns a <code>List</code>; Kotlin will complain, so you must give the type parameter as well. When you specify the return type of a function, Kotlin enforces your intention.</p>
<h2 id="read-only-and-mutable-lists">Read-only and Mutable Lists</h2>
<p>If you don’t explicitly say you want a mutable <code>List</code>, you won’t get one. <code>listOf()</code> produces a read-only list without mutating functions.</p>
<p>If you’re creating a list gradually (you don’t have all the elements at creation time), call <code>mutableListOf()</code>. This produces a <code>MutableList</code> which can be modified:</p>
<div class="sourceCode" id="cb6"><code class="sourceCode kotlin"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="co">// Lists/MutableList.kt</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="kw">import</span> <span class="im">atomictest.eq</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="kw">fun</span> <span class="fu">main</span>(<span class="va">args</span>: <span class="dt">Array</span>&lt;<span class="va">String</span>&gt;) {</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  <span class="kw">val</span> <span class="va">list</span> = mutableListOf&lt;<span class="kw">Int</span>&gt;()</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">  list.add(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">  list.addAll(listOf(<span class="dv">2</span>, <span class="dv">3</span>))</a>
<a class="sourceLine" id="cb6-9" data-line-number="9"></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">  list += <span class="dv">4</span></a>
<a class="sourceLine" id="cb6-11" data-line-number="11">  list += listOf(<span class="dv">5</span>, <span class="dv">6</span>)</a>
<a class="sourceLine" id="cb6-12" data-line-number="12"></a>
<a class="sourceLine" id="cb6-13" data-line-number="13">  list eq listOf(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>)</a>
<a class="sourceLine" id="cb6-14" data-line-number="14">}</a></code></div>
<p>You can add elements to a <code>MutableList</code> using <code>add()</code> and <code>addAll()</code>, or the shortcut <code>+=</code> which adds a single element or another collection. Because <code>list</code> is given no initial elements, we must tell the compiler what type it is with the <code>&lt;Int&gt;</code> specification.</p>
<p>A <code>MutableList</code> can be treated as a <code>List</code>, in which case it cannot be changed. You can’t, however, treat a read-only <code>List</code> as a <code>MutableList</code>:</p>
<div class="sourceCode" id="cb7"><code class="sourceCode kotlin"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="co">// Lists/MutListIsList.kt</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="kw">import</span> <span class="im">atomictest.eq</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"></a>
<a class="sourceLine" id="cb7-4" data-line-number="4"><span class="kw">fun</span> <span class="fu">getList</span>(): <span class="dt">List</span>&lt;<span class="dt">Int</span>&gt; {</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  <span class="kw">return</span> mutableListOf(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">}</a>
<a class="sourceLine" id="cb7-7" data-line-number="7"></a>
<a class="sourceLine" id="cb7-8" data-line-number="8"><span class="kw">fun</span> <span class="fu">main</span>(<span class="va">args</span>: <span class="dt">Array</span>&lt;<span class="va">String</span>&gt;) {</a>
<a class="sourceLine" id="cb7-9" data-line-number="9">  <span class="co">// getList() produces a read-only List:</span></a>
<a class="sourceLine" id="cb7-10" data-line-number="10">  <span class="kw">val</span> <span class="va">list</span> = getList()</a>
<a class="sourceLine" id="cb7-11" data-line-number="11">  <span class="co">// list += 3 // Error</span></a>
<a class="sourceLine" id="cb7-12" data-line-number="12">  list eq listOf(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb7-13" data-line-number="13">}</a></code></div>
<p>Note that <code>list</code> lacks mutation functions despite being originally created using <code>mutableListOf()</code> inside <code>getList()</code>. As <code>getList()</code> returns the result, the type becomes a <code>List&lt;Int&gt;</code>. The original object is still a <code>MutableList</code>, but it is viewed through the lens of a <code>List</code>.</p>
<p>A <code>List</code> is <em>read-only</em>—you can read its contents but not write to it. If the underlying implementation is a <code>MutableList</code> and you retain a mutable reference to that implementation, you can still modify it via that mutable reference, and any read-only references will see those changes. This is another example of the problem of <em>aliasing</em>, which was introduced in <a target="_blank" href="024_Constraining_Visibility.html">Constraining Visibility</a>:</p>
<div class="sourceCode" id="cb8"><code class="sourceCode kotlin"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="co">// Lists/MultipleListRefs.kt</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="kw">import</span> <span class="im">atomictest.eq</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4"><span class="kw">fun</span> <span class="fu">main</span>(<span class="va">args</span>: <span class="dt">Array</span>&lt;<span class="va">String</span>&gt;) {</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  <span class="kw">val</span> <span class="va">first</span> = mutableListOf(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">  <span class="kw">val</span> <span class="va">second</span>: List&lt;<span class="kw">Int</span>&gt; = first</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">  second eq listOf(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb8-8" data-line-number="8"></a>
<a class="sourceLine" id="cb8-9" data-line-number="9">  first += <span class="dv">2</span></a>
<a class="sourceLine" id="cb8-10" data-line-number="10">  <span class="co">// second sees the change:</span></a>
<a class="sourceLine" id="cb8-11" data-line-number="11">  second eq listOf(<span class="dv">1</span>, <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb8-12" data-line-number="12">}</a></code></div>
<p><code>first</code> is an immutable reference (<code>val</code>) to the mutable object produced by <code>mutableListOf(1)</code>. <code>second</code> is aliased to <code>first</code>. <code>second</code> is a reference to a read-only view of that same object; read-only because <code>List&lt;Int&gt;</code> does not include any modification functions. Note that, without the <code>List&lt;Int&gt;</code> type declaration, Kotlin would infer that <code>second</code> was also a reference to a mutable object.</p>
<p>We’re able to add one more element (<code>2</code>) to the object through the <code>first</code> reference, because <code>first</code> is a reference to a mutable list. Note that <code>second</code> observes these changes—it cannot change the list itself, even though the list does change.</p>
<p class="copy">
©2018 <a href="http://mindviewllc.com/">Mindview LLC</a>. All Rights Reserved.
</p>
<p><br><br></p>
</body>
</html>
